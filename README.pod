=encoding utf8

=head1 NAME

List::Prefixed - Prefixed string list implementation

=head1 SYNOPSIS

  use List::Prefixed;

  # construct a new prefixed tree
  $folded = List::Prefixed->fold(qw( Fu Foo For Form Foot Food Ba Bar Baz ));

  # get all items sharing a common prefix
  @list = $folded->list('Fo'); # Foo, Food, Foot, For, Form

  # serialize as regular expression
  $regex = $folded->regex; # '(?:Ba(?:r|z)?|F(?:o(?:o(?:d|t)?|r(?:m)?)|u))'

  # de-serialize from regular expression
  $unfolded = List::Prefixed->unfold($regex);

=head1 DESCRIPTION

The idea of Prefixed Lists comes from regular expressions determining a finite
list of words, like this:

  /(?:Ba(?:r|z)?|F(?:o(?:o(?:d|t)?|r(?:m)?)|u))/
  
The expression above matches exactly these strings:

  "Ba", "Bar", "Baz", "Foo", "Food", "Foot", "For", "Form", "Fu".

Representing a string list that way may have some advantages in certain situations:

=over 4

=item *

The representation as a regular expression provides efficient methods to test whether
or not an arbitrary string starts or ends with an element from the list or is contained
in the list itself.

=item *

The representaion is compressing, depending on how many shared prefixes appear in a list.

=item *

Conversely, a prefixed list can be efficiently set up from such a regular expression.
Thus, the prefixed list leads to a natural way of serialization and de-serialization.

=item *

Sub lists sharing a common prefix can be extracted efficently from a prefixed list. 
This leads to an efficient implementation of auto-completion.

=back

=head1 METHODS

=head2 new

  $prefixed = List::Prefixed->new( @list );

This is an alias of the L<fold|fold> method.

=head2 fold

  $prefixed = List::Prefixed->fold( @list );

Constructs a new L<List::Prefixed|List::Prefixed> tree from the given string list.

=head2 unfold

  $prefixed = List::Prefixed->unfold( $regex );

Constructs a new L<List::Prefixed|List::Prefixed> tree from a regular expression string.
The string argument shuld be obtained from the L<regex|regex> method.

=head2 list

  @list = $prefixed->list;
  @list = $prefixed->list( $string );

Returns the list of strings starting with the given argument if a string argument
is present or the whole list otherwise. In scalar context an ARRAY reference is
returned.

=head2 regex

  $regex = $prefixed->regex;

Returns a minimized regular expression (as string) matching exactly the strings
the object has been constructed with.

You can control the escaping style of the expression. The default behavior is
to apply Perl's P<quotemeta> function and replace any non-ASCII character with
C<\x{FFFF}>, where C<FFFF> is the hexadecimal character code. This is the
Perl-compatible or PCRE style. To obtain an expression compatible with Java
and the like, use

  use List::Prefixed uc_escape_style => 'Java'; # \uFFFF style

To skip Unicode escaping completely, use

  use List::Prefixed uc_escape_style => undef;  # do not escape

Alternatively, you can control the style at runtime by way of
L<CONFIGURATION VARIABLES|configuration variables>.

=head1 CONFIGURATION VARIABLES

=over 4

=item I<$UC_ESCAPE_STYLE>

Control the escaping style for Unicode (non-ASCII) characters.
The value can be ono of the following:

=over 4

=item I<'PCRE'>

Default style C<\x{FFFF}>

=item I<'Java'>

Java etc. style C<\uFFFF>

=item I<undef>

Do not escape Unicode characters at all. This may result in shorter expressions
but may cause encoding issues under some circumstances.

=item I<$REGEX_ESCAPE>, I<$REGEX_UNESCAPE>

By providing string functions one can customize the escaping behavior arbitrarily.
In this case, C<$UC_ESCAPE_STYLE> has no effect.

=back

=back

=head1 EXPORT

Strictly OO, exports nothing.

=head1 REPOSITORY

L<https://github.com/boethin/List-Prefixed>

=head1 AUTHOR

Sebastian Böthin, E<lt>boethin@xn--domain.netE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2015 by Sebastian Böthin

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.14.2 or,
at your option, any later version of Perl 5 you may have available.

